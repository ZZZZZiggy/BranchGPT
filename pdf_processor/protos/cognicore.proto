syntax = "proto3";

package cognicore;

// ==================== 数据结构 ====================

// 文本块（你发送给 Go 的数据）
message TextChunk {
    string chunk_id = 1;           // 当前 chunk 的唯一 ID（可选，如果 Go 不需要可以不传）
    string file_id = 2;            // 文件 ID（必需，标识这是哪个文件的 chunk）
    string chapter = 3;            // 章节标题
    string chapter_num = 4;        // 章节号（例如 "1.2", "3.2.1"）
    string chunk_text = 5;         // 文本内容
    repeated float embedding_vector = 6;  // 向量（float 数组，不是 string！）
    int32 chunk_index = 8;         // 这是第几个 chunk（从 0 开始）
}

// 文档元信息（在开始发送 chunks 之前先发这个）
message DocumentMetadata {
    string file_id = 1;            // 文件 ID
    string user_id = 2;            // 用户 ID
    string filename = 3;           // 文件名
    int32 total_pages = 4;         // 总页数
    int32 estimated_chunks = 5;    // 预计会发送多少个 chunks
    string file_hash = 6;          // 文件哈希（用于去重）
    int64 file_size = 7;           // 文件大小（字节）
    string created_at = 8;         // 处理时间
}

// 流式请求（可以是元信息或 chunk）
message IngestRequest {
    oneof request_type {
        DocumentMetadata metadata = 1;  // 第一条消息：元信息
        TextChunk chunk = 2;             // 后续消息：文本块
    }
}

// ==================== 响应结构 ====================

// Go backend 的 ACK 响应
message IngestResponse {
    bool success = 1;                    // 是否成功
    string message = 2;                  // 消息（成功/失败原因）

    // 统计信息
    int32 chunks_received = 3;           // 收到了多少个 chunks
    int32 chunks_stored = 4;             // 成功存储了多少个
    int32 chunks_failed = 5;             // 失败了多少个

    // 处理时间（毫秒）
    int64 processing_time_ms = 7;

    // 文件 ID 用于确认
    string file_id = 8;
}


message APIKeyRequest {
    string task_id = 1;  // 任务 ID（用于匹配）
    string api_key = 2;  // API Key (OpenAI, Gemini, etc.)
    string provider = 3; // Provider name: "openai" or "gemini"
}

message APIKeyResponse {
    bool success = 1;
    string message = 2;
}

message EmbeddingRequest {
    string task_id = 1;      // 任务 ID（用于日志追踪）
    string text = 2;         // 要向量化的文本
    string api_key = 3;      // API Key (OpenAI, Gemini, etc.)
    string provider = 4;     // Provider name: "openai" or "gemini"
}

message EmbeddingResponse {
    bool success = 1;
    string message = 2;
    repeated float embeddings = 3;  // 向量结果（float 数组）
    int32 dimension = 4;            // 向量维度
}
// ==================== 服务定义 ====================

// 数据导入服务
// 角色分配：
//   - Go：服务端（Server），实现这个服务，监听端口，等待 Python 连接
//   - Python：客户端（Client），连接 Go，调用这个服务，发送数据
// 数据流向：Python → Go
service IngestService {
    // Client Streaming: Python 持续发送文档数据，Go 最后返回一次 ACK
    // 使用场景：处理整个 PDF，发送 metadata + 所有 chunks
    rpc IngestDocument(stream IngestRequest) returns (IngestResponse);

    // Unary 模式：单个 chunk 上传
    // 使用场景：重试失败的 chunk，或者测试单个 chunk
    rpc IngestSingleChunk(TextChunk) returns (IngestResponse);
}

// API Key 传递
service APIKeyService {
    // Go 调用 Python：传递 API Key
    rpc ProvideAPIKey(APIKeyRequest) returns (APIKeyResponse);
}

// Embedding 服务
// 角色分配：
//   - Python：服务端（Server），实现这个服务，监听端口，等待 Go 连接
//   - Go：客户端（Client），连接 Python，调用这个服务，发送文本进行向量化
// 数据流向：Go → Python → Go
service EmbeddingService {
    // Go 调用 Python：发送文本，获取向量
    rpc GetEmbedding(EmbeddingRequest) returns (EmbeddingResponse);
}
